{{ define "request-detail" }}
<div class="flex flex-col h-full overflow-hidden" data-content-type="{{ .ContentType }}">
    <!-- Compact Header -->
    <div class="px-4 py-2 border-b border-slate-800 bg-slate-900/40 flex items-center justify-between shrink-0">
        <div class="flex items-center gap-3 min-w-0">
            <span class="text-xs font-bold {{ if eq .Method "GET" }}text-emerald-500{{ else }}text-brand-400{{ end }} font-mono bg-slate-900/50 px-1.5 py-0.5 rounded border border-slate-800/50">{{ .Method }}</span>
            <span class="text-xs text-slate-200 font-mono truncate max-w-xl">{{ .Path }}</span>
        </div>
        <div class="flex items-center gap-1.5">
            <button class="text-[10px] font-bold text-white bg-brand-600 hover:bg-brand-500 px-2.5 py-1 rounded-md transition-all active:scale-95 flex items-center gap-1.5 shadow-lg shadow-brand-600/5"
                    data-request-id="{{ .ID }}"
                    hx-post=""
                    hx-swap="none"
                    hx-on::before-request="setReplayUrl(this); handleReplayBefore(this)"
                    hx-on::after-request="handleReplayAfter(this)">
                <i class="fas fa-repeat text-[9px]"></i>
                Replay
            </button>
            <button class="text-[10px] font-bold text-white bg-red-600 hover:bg-red-500 px-2.5 py-1 rounded-md transition-all active:scale-95 flex items-center gap-1.5 shadow-lg shadow-red-600/5"
                    data-request-id="{{ .ID }}"
                    data-endpoint-id="{{ .EndpointID }}"
                    hx-delete=""
                    hx-target="body"
                    hx-swap="none"
                    hx-on::before-request="setDeleteRequestUrl(this)"
                    hx-on::after-request="handleDeleteRequest(this)">
                <i class="fas fa-trash-can text-[9px]"></i>
                Delete
            </button>
        </div>
    </div>

    <!-- Scrollable Content -->
    <div class="flex-1 overflow-y-auto custom-scrollbar p-4 space-y-4">
        <!-- Headers -->
        <div>
            <div class="flex items-center justify-between mb-1.5">
                <button onclick="toggleSection('headers-section')" class="text-[10px] font-bold text-slate-500 uppercase tracking-widest flex items-center gap-2 hover:text-slate-400 transition-colors">
                    <i class="fas fa-list-ul text-[9px]"></i>
                    Headers
                    <i id="headers-chevron" class="fas fa-chevron-down text-[7px] transition-transform"></i>
                </button>
                <div class="flex items-center gap-2">
                    <button onclick="toggleHeadersView()" class="text-slate-600 hover:text-brand-400 transition-colors p-1 rounded hover:bg-slate-800" title="Toggle view" id="headers-view-toggle">
                        <i class="fas fa-code text-[10px]"></i>
                    </button>
                    <button onclick="copyHeaders()" class="text-slate-600 hover:text-brand-400 transition-colors p-1 rounded hover:bg-slate-800" title="Copy headers">
                        <i class="far fa-copy text-[10px]"></i>
                    </button>
                </div>
            </div>
            <div id="headers-section" class="bg-slate-950 border border-slate-800 rounded-lg overflow-hidden shadow-xl">
                <!-- JSON View (default) -->
                <div id="headers-json-view" class="relative overflow-auto max-h-[150px] custom-scrollbar">
                    <pre class="text-[11px] font-mono text-slate-300 py-2 px-3 m-0 leading-tight whitespace-pre overflow-x-auto">{{ .HeadersJSON }}</pre>
                </div>
                <!-- List View (hidden by default) -->
                <div id="headers-list-view" class="divide-y divide-slate-800/20 hidden max-h-[150px] overflow-y-auto custom-scrollbar">
                    {{ range $key, $values := .HeadersMap }}
                    <div class="px-3 py-1.5 hover:bg-slate-800/40 transition-colors">
                        <div class="text-[9px] text-slate-500 font-mono font-semibold mb-0.5 uppercase tracking-wider">{{ $key }}</div>
                        <div class="text-[11px] text-brand-300 font-mono break-all leading-tight">{{ index $values 0 }}</div>
                    </div>
                    {{ end }}
                </div>
            </div>
        </div>

        <!-- Body -->
        <div>
            <div class="flex items-center justify-between mb-1.5">
                <button onclick="toggleSection('body-section')" class="text-[10px] font-bold text-slate-500 uppercase tracking-widest flex items-center gap-2 hover:text-slate-400 transition-colors">
                    <i class="fas fa-code text-[9px]"></i>
                    Payload Body
                    <i id="body-chevron" class="fas fa-chevron-down text-[7px] transition-transform"></i>
                </button>
                <div class="flex items-center gap-2">
                    <span class="text-[9px] text-slate-600 bg-slate-900/50 border border-slate-800 px-1.5 py-0.5 rounded font-mono">{{ len .Body }} bytes</span>
                    {{ if .ContentType }}
                    <span class="text-[9px] text-slate-500 bg-slate-900/50 border border-slate-800 px-1.5 py-0.5 rounded font-mono">{{ .ContentType }}</span>
                    {{ end }}
                    {{ if not .IsBinary }}
                    <button onclick="formatBody()" class="text-slate-600 hover:text-brand-400 transition-colors p-1 rounded hover:bg-slate-800" title="Format/Prettify">
                        <i class="fas fa-indent text-[10px]"></i>
                    </button>
                    {{ end }}
                    <button onclick="copyBody()" class="text-slate-600 hover:text-brand-400 transition-colors p-1 rounded hover:bg-slate-800" title="Copy body">
                        <i class="far fa-copy text-[10px]"></i>
                    </button>
                </div>
            </div>
            <div id="body-section" class="bg-slate-950 border border-slate-800 rounded-lg overflow-hidden shadow-xl">
                <!-- Code Editor Content -->
                <div class="relative overflow-auto max-h-[600px] custom-scrollbar">
                    <div class="flex">
                        <!-- Line Numbers -->
                        <div id="line-numbers" class="bg-slate-900/80 text-slate-600 text-[10px] font-mono py-2 px-2 text-right select-none border-r border-slate-800/30 sticky left-0"></div>
                        <!-- Code Content -->
                        {{ if .IsBinary }}
                        <div class="flex-1 py-4 px-4 flex items-center justify-center">
                            <div class="text-center">
                                <i class="fas fa-file-binary text-3xl text-slate-700 mb-2"></i>
                                <p class="text-[10px] text-slate-500 font-mono">Binary content ({{ len .Body }} bytes)</p>
                                <p class="text-[9px] text-slate-600 mt-1">Cannot display binary data</p>
                            </div>
                        </div>
                        {{ else }}
                        <pre id="body-raw" class="flex-1 text-[11px] font-mono py-2 px-3 m-0 leading-normal whitespace-pre overflow-x-auto">{{ if .BodyString }}{{ .BodyString | html }}{{ else }}<span class="text-slate-600 italic">Empty body</span>{{ end }}</pre>
                        {{ end }}
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div data-request-detail-script style="display: none;">
        <script type="text/plain">
        (function() {
            function setReplayUrl(button) {
                const requestId = button ? button.getAttribute('data-request-id') : null;
                if(requestId) {
                    button.setAttribute('hx-post', '/r/' + requestId + '/replay');
                }
            }
            window.setReplayUrl = setReplayUrl;

            function handleReplayBefore(button) {
                if(button) {
                    button.classList.add('opacity-50', 'pointer-events-none');
                    const icon = button.querySelector('i');
                    if(icon) icon.classList.add('animate-spin');
                }
            }
            window.handleReplayBefore = handleReplayBefore;

            function handleReplayAfter(button) {
                if(button) {
                    button.classList.remove('opacity-50', 'pointer-events-none');
                    const icon = button.querySelector('i');
                    if(icon) icon.classList.remove('animate-spin');
                }
            }
            window.handleReplayAfter = handleReplayAfter;

            function setDeleteRequestUrl(button) {
                const requestId = button ? button.getAttribute('data-request-id') : null;
                if(requestId) {
                    button.setAttribute('hx-delete', '/r/' + requestId);
                }
            }
            window.setDeleteRequestUrl = setDeleteRequestUrl;

            function handleDeleteRequest(button) {
                // HTMX provides event as a global variable
                if(typeof event !== 'undefined' && event.detail && event.detail.xhr && event.detail.xhr.status === 200) {
                    const requestId = button.getAttribute('data-request-id');
                    const endpointId = button.getAttribute('data-endpoint-id');
                    if(requestId) {
                        const listItem = document.querySelector('[data-request-id="' + requestId + '"]');
                        if(listItem) listItem.remove();
                    }
                    const count = document.getElementById('request-count');
                    if(count) {
                        const current = parseInt(count.innerText) || 0;
                        count.innerText = Math.max(0, current - 1);
                    }
                    if(endpointId) {
                        window.location.href = '/' + endpointId;
                    }
                }
            }
            window.handleDeleteRequest = handleDeleteRequest;

            function toggleSection(sectionId) {
                const section = document.getElementById(sectionId);
                const chevron = document.getElementById(sectionId.replace('-section', '-chevron'));
                if (section && chevron) {
                    const isHidden = section.classList.contains('hidden');
                    if (isHidden) {
                        section.classList.remove('hidden');
                        chevron.classList.remove('rotate-180');
                    } else {
                        section.classList.add('hidden');
                        chevron.classList.add('rotate-180');
                    }
                }
            }
            window.toggleSection = toggleSection;

            const bodyRaw = document.getElementById('body-raw');
            const lineNumbers = document.getElementById('line-numbers');
            const contentTypeElement = document.querySelector('[data-content-type]');
            const contentType = contentTypeElement ? contentTypeElement.getAttribute('data-content-type') : 'text/plain';
            let isJSON = false;
            let isXML = false;
            let isHTML = false;

            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            // Get raw text content from HTML-escaped content
            function getRawText(element) {
                if (!element) return '';
                // textContent automatically decodes HTML entities
                return element.textContent || element.innerText || '';
            }

            function highlightJSON(text) {
                if (!isJSON) return escapeHtml(text);

                // Escape HTML first
                text = escapeHtml(text);

                // Highlight JSON syntax
                return text
                    .replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function(match) {
                        let cls = 'text-slate-200';
                        if (/^"/.test(match)) {
                            if (/:$/.test(match)) {
                                cls = 'text-brand-400'; // key
                            } else {
                                cls = 'text-emerald-400'; // string value
                            }
                        } else if (/true|false/.test(match)) {
                            cls = 'text-purple-400'; // boolean
                        } else if (/null/.test(match)) {
                            cls = 'text-slate-500'; // null
                        } else {
                            cls = 'text-blue-400'; // number
                        }
                        return '<span class="' + cls + '">' + match + '</span>';
                    })
                    .replace(/([{}[\],:])/g, '<span class="text-slate-400">$1</span>');
            }

            function updateLineNumbers() {
                if (!bodyRaw || !lineNumbers) return;
                const text = bodyRaw.innerText || bodyRaw.textContent || '';
                const lines = text.split('\n');
                lineNumbers.innerHTML = lines.map((_, i) => `<div class="leading-relaxed">${i + 1}</div>`).join('');
            }

            function detectContentType(text, headerType) {
                // Check header first
                if (headerType) {
                    const lower = headerType.toLowerCase();
                    if (lower.includes('json')) return 'json';
                    if (lower.includes('xml')) return 'xml';
                    if (lower.includes('html')) return 'html';
                }

                // Try to detect from content
                const trimmed = text.trim();
                if (trimmed.startsWith('{') || trimmed.startsWith('[')) {
                    try {
                        JSON.parse(trimmed);
                        return 'json';
                    } catch (e) {}
                }
                if (trimmed.startsWith('<?xml') || trimmed.startsWith('<') && trimmed.includes('>')) {
                    if (trimmed.includes('<!DOCTYPE html') || trimmed.includes('<html')) {
                        return 'html';
                    }
                    return 'xml';
                }
                return 'text';
            }

            function formatXML(xml) {
                let formatted = '';
                let indent = 0;
                const tab = '  ';
                xml.split(/>\s*</).forEach(function(node) {
                    if (node.match(/^\/\w/)) indent--;
                    formatted += tab.repeat(indent) + '<' + node + '>\r\n';
                    if (node.match(/^<?\w[^>]*[^\/]$/) && !node.startsWith('<?xml')) indent++;
                });
                return formatted.substring(1, formatted.length - 2);
            }

            function formatAndHighlight() {
                if (!bodyRaw) return;
                // Get raw text - textContent automatically decodes HTML entities
                const originalText = getRawText(bodyRaw);

                if (!originalText.trim()) {
                    updateLineNumbers();
                    return;
                }

                const detectedType = detectContentType(originalText, contentType);

                if (detectedType === 'json') {
                    try {
                        // Parse and format JSON with proper indentation (2 spaces)
                        const json = JSON.parse(originalText);
                        const formatted = JSON.stringify(json, null, 2);
                        bodyRaw.innerHTML = highlightJSON(formatted);
                        isJSON = true;
                        updateLineNumbers();
                        return;
                    } catch (e) {
                        // If JSON parsing fails, still try to display with syntax highlighting
                        // in case it's malformed JSON
                        console.log('JSON parse error:', e);
                    }
                }

                // Not JSON or failed to parse, display as-is
                bodyRaw.textContent = originalText;
                isJSON = false;
                isXML = false;
                isHTML = false;
                updateLineNumbers();
            }

            function formatBody() {
                if (!bodyRaw) return;
                // Get raw text - textContent automatically decodes HTML entities
                const text = getRawText(bodyRaw);
                if (!text.trim()) return;

                const detectedType = detectContentType(text, contentType);

                if (detectedType === 'json') {
                    try {
                        // Parse and format JSON with proper indentation (2 spaces)
                        const json = JSON.parse(text);
                        const formatted = JSON.stringify(json, null, 2);
                        bodyRaw.innerHTML = highlightJSON(formatted);
                        isJSON = true;
                        updateLineNumbers();
                        if (typeof showToast === 'function') {
                            showToast('JSON formatted', 'success');
                        }
                    } catch (e) {
                        if (typeof showToast === 'function') {
                            showToast('Not valid JSON: ' + e.message, 'error');
                        }
                    }
                } else if (detectedType === 'xml') {
                    try {
                        const formatted = formatXML(text);
                        bodyRaw.textContent = formatted;
                        isXML = true;
                        updateLineNumbers();
                        if (typeof showToast === 'function') {
                            showToast('XML formatted', 'success');
                        }
                    } catch (e) {
                        if (typeof showToast === 'function') {
                            showToast('Failed to format XML', 'error');
                        }
                    }
                } else {
                    if (typeof showToast === 'function') {
                        showToast('No formatting available for this content type', 'info');
                    }
                }
            }

            window.formatBody = formatBody;

            function copyBody() {
                if (!bodyRaw) {
                    // If binary, show message
                    if (typeof showToast === 'function') {
                        showToast('Cannot copy binary content', 'info');
                    }
                    return;
                }
                const text = bodyRaw.innerText || bodyRaw.textContent || '';
                navigator.clipboard.writeText(text).then(() => {
                    if (typeof showToast === 'function') {
                        showToast('Body copied to clipboard', 'success');
                    }
                }).catch(() => {
                    if (typeof showToast === 'function') {
                        showToast('Failed to copy', 'error');
                    }
                });
            }
            window.copyBody = copyBody;

            let headersViewMode = 'json'; // Default to JSON view

            function toggleHeadersView() {
                const jsonView = document.getElementById('headers-json-view');
                const listView = document.getElementById('headers-list-view');
                const toggleBtn = document.getElementById('headers-view-toggle');

                if (!jsonView || !listView || !toggleBtn) return;

                if (headersViewMode === 'json') {
                    // Switch to list view
                    jsonView.classList.add('hidden');
                    listView.classList.remove('hidden');
                    toggleBtn.innerHTML = '<i class="fas fa-list-ul text-xs"></i>';
                    headersViewMode = 'list';
                } else {
                    // Switch to JSON view
                    jsonView.classList.remove('hidden');
                    listView.classList.add('hidden');
                    toggleBtn.innerHTML = '<i class="fas fa-code text-xs"></i>';
                    headersViewMode = 'json';
                }
            }
            window.toggleHeadersView = toggleHeadersView;

            function copyHeaders() {
                const jsonView = document.getElementById('headers-json-view');
                const listView = document.getElementById('headers-list-view');
                const activeView = headersViewMode === 'json' ? jsonView : listView;

                if (!activeView) return;
                const text = activeView.innerText || activeView.textContent || '';
                navigator.clipboard.writeText(text).then(() => {
                    if (typeof showToast === 'function') {
                        showToast('Headers copied to clipboard', 'success');
                    }
                }).catch(() => {
                    if (typeof showToast === 'function') {
                        showToast('Failed to copy', 'error');
                    }
                });
            }
            window.copyHeaders = copyHeaders;

            // Auto-format on load (only if bodyRaw exists, i.e., not binary)
            if (bodyRaw) {
                formatAndHighlight();
            }
        })();
        </script>
    </div>
</div>
{{ end }}
